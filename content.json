{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://jsakura.github.io","root":"/"},"pages":[],"posts":[{"title":"js预解析","slug":"js预解析","date":"2019-07-30T10:01:52.000Z","updated":"2019-08-26T09:32:57.620Z","comments":true,"path":"2019/07/30/js预解析/","link":"","permalink":"https://jsakura.github.io/2019/07/30/js预解析/","excerpt":"","text":"JS的解析过程分为两个阶段：预编译期与执行期。 预编译期：找程序中var关键字，如果找到了提前给var定义的变量赋值undefined 找程序中的普通函数，如果找到了，函数提升，将整个函数赋值给函数名。 如果找的var的名字和函数名字相同，函数优先。 执行期: 逐行解析代码。按照上下顺序。如果碰到函数定义，忽略。重点：函数内部同样适用于js预解析。","categories":[],"tags":[]},{"title":"es6","slug":"es6","date":"2019-07-28T09:54:03.000Z","updated":"2020-06-28T15:00:49.524Z","comments":true,"path":"2019/07/28/es6/","link":"","permalink":"https://jsakura.github.io/2019/07/28/es6/","excerpt":"","text":"es6新增数组 entries()方法返回一个新Array Iterator对象，该对象包含数组中每个索引的键 / 值对。判断数组中是否每个元素都满足条件 只有都满足条件才返回true； 12345var arr10 = [1, 2, 3, 4, 5, 6]for (const [index, element] of arr10.entries console.log(index, element);()) 判断数组中是否每个元素都满足条件 只要有一个满足就返回true 只有都不满足时才返回false； 123arr2.some(function (value, index, array) &#123; return value % 2 == 0;&#125;) 该every()方法测试数组中的所有元素是否都通过了由提供的函数实现的测试。它返回一个布尔值。 1[12, 5, 8, 130, 44].every(x =&gt; x &gt;= 10); // false find()方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 1[1, 2, 5, -1, 9].find((n) =&gt; n &lt; 0) findIndex()方法的用法与find()方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 - 1。 1[1, 2, 5, -1, 9].findIndex((n) =&gt; n &lt; 0) filter()方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。filter 不会改变原数组。 数组去重 12var arr = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 0, 8, 6, 3, 4, 56, 2];var arr2 = arr.filter((x, index, self) =&gt; self.indexOf(x) === index) forEach() 12345678var arr = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 0, 8, 6, 3, 4, 56, 2];var newarr = []arr.forEach((x, index, self) =&gt; &#123; if (self.indexOf(x) === index) &#123; newarr.push(x) &#125;&#125;)console.log(newarr) map() 原数组被“映射”成对应新数组, 返回一个新数组 12345678var building = [ &#123; name: 'the Great Wall', location: 'BeiJing' &#125;, &#123; name: 'Eiffel Tower', location: 'Paris ' &#125;]var citys = building.map(item =&gt; &#123; return item.location&#125;)console.log(citys) reduce 对每个数组中的每项进行累加 12345var numbers = [1, 2, 3, 4, 5];var sumValue = numbers.reduce(function (sum, number2) &#123; //第一个参数为叠加总值，需要初始化，第二个参数是当前项 return sum + number2;&#125;, 0); //sum的初始化 console.log(sumValue); //15","categories":[],"tags":[]},{"title":"js数组方法","slug":"js数组方法","date":"2019-07-26T09:48:47.000Z","updated":"2019-09-08T13:42:45.893Z","comments":true,"path":"2019/07/26/js数组方法/","link":"","permalink":"https://jsakura.github.io/2019/07/26/js数组方法/","excerpt":"","text":"1.push 向数组尾部添加新内容，返回数组长度 12345678910var arr1 = [1, 2, 3]console.log(arr1.push([4, 5]), arr1)Array.prototype.push1 = function () &#123; for (let i = 0; i &lt; arguments.length; i++) &#123; this[this.length] = arguments[i]; &#125; return this.length;&#125;console.log(arr1.push1([1.2]), arr1) 2.pop方法是移除数组末尾的元素, 并返回该元素 123456789var arr2 = []console.log(arr2.pop(), arr2)Array.prototype.pop1 = function () &#123; var last = this[this.length - 1]; this.length == 0 ? last = undefined : this.length = this.length - 1 return last&#125;console.log(arr2.pop1(), arr2) 3.shift会移除数组的第一项元素，并返回该元素 123456789101112var arr3 = [1, 2, 3]console.log(arr3.shift())Array.prototype.shift1 = function () &#123; var first = this[0]; for (let i = 1; i &lt; this.length; i++) &#123; this[i - 1] = this[i] &#125; this.length = this.length - 1 return first&#125;console.log(arr3.shift1()) 4.unshift方法是向前端添加任意个长度的数组，并返回数组的长度。 123456789101112131415161718192021222324var arr4 = [1, 2, 3, 4]console.log(arr4.unshift(5, 6, 7), arr4)Array.prototype.unshift1 = function () &#123; var L = this.length; for (var i = L + arguments.length - 1; i &gt;= 0; i--) &#123; if (i &gt; arguments.length - 1) &#123; this[i] = this[i - arguments.length]; &#125; else &#123; this[i] = arguments[i]; &#125; &#125; var newarr = [] for (var i = 0; i &lt; L; i++) &#123; newarr[i + arguments.length] = this[i] for (var t = 0; t &lt; arguments.length; t++) &#123; newarr[t] = arguments[t] &#125; &#125; this == newarr return this.length&#125;console.log(arr4.unshift1(5, 6, 7), arr4) 5.concat在没有参数的时候，会复制当前数组，返回副本。但有一个或多个数组，会把这些添加到结果数组中。 123456789101112131415var arr5 = [0, 1, 9, 5]console.log(arr5.concat('5555, 666'), arr5)Array.prototype.concat1 = function () &#123; var newarr = JSON.parse(JSON.stringify(this)) if (arguments.length &gt; 0) &#123; for (let i = 0; i &lt; arguments.length; i++) &#123; newarr[newarr.length] = arguments[i] &#125; return newarr &#125; else &#123; return this &#125;&#125;console.log(arr5.concat1(5555, 666, 7, 8, 9), arr5) 6.slice是从指定位置截取数组，并返回截取的数组，不包括结束位置的项 可以传两个参数，不改变原数组 1234567891011121314151617181920var arr6 = [\"q\", \"w\", \"e\", \"r\", \"t\", \"y\"]console.log(arr6.slice())Array.prototype.slice1 = function () &#123; var len var newarr = JSON.parse(JSON.stringify(this)) arguments[1] &lt; 0 ? arguments[1] = newarr.length + arguments[1] : arguments[1] arguments.length &gt; 1 ? len = arguments[1] - arguments[0] : newarr.length - arguments[0] if (len &gt; 0) &#123; for (var i = 0; i &lt; arguments[1] - arguments[0]; i++) &#123; newarr[i] = this[arguments[0] + i] &#125; newarr.length = len return newarr &#125; else &#123; return [] &#125;&#125;console.log(arr6.slice(a), arr6) 7.splice是一个强大的数组。它既可以删除数据也可以插入数据，也可以删除、替换数据 可以传3个参数，改变原数组 12345678910111213141516171819202122232425262728var arr7 = ['q', 'w', 's', 'f', 'g', 'c']console.log(arr7.splice(1, 6), arr7)Array.prototype.splice1 = function () &#123; var len var newarr = JSON.parse(JSON.stringify(this)) arguments[0] &lt; 0 ? arguments[0] = newarr.length + arguments[0] : arguments[0] arguments[0] &lt; 0 ? arguments[1] = newarr.length : arguments[1] arguments.length &gt; 1 ? len = arguments[1] - arguments[0] : newarr.length - arguments[0] if (len &gt; 0) &#123; for (var i = 0; i &lt; this.length; i++) &#123; if (i &lt; arguments[0]) &#123;// i&lt;3 012 this[i] = newarr[i] &#125; else if (arguments[1] &gt; i &gt;= arguments[0]) &#123; //5&gt;i&gt;=3 34 newarr[i] = this[arguments[0] + i] &#125; else &#123; //i&gt;5 56 34 this[i - arguments[0] + 1] = newarr[i] &#125; console.log(this) &#125; newarr.length = len return newarr &#125; else &#123; return [] &#125;&#125;console.log(arr7.splice1(1, 6), arr7) //没写完 8.join方法可以将数组通过指定的字符连接在一起，然后以字符串的形式输出 不改变原数组 123456789101112131415var arr8 = [];console.log(arr.join(2), arr); //1&amp;2&amp;3Array.prototype.join1 = function () &#123; var str = '', ls = ''; arguments.length == 0 ? ls = ',' : ls = arguments[0] for (let i = 0; i &lt; this.length - 1; i++) &#123; str += this[i] + \"\" + ls &#125; str += this[this.length - 1] this.length == 0 ? str = '' : str return str&#125;console.log(arr8.join1(2), arr); //1&amp;2&amp;3 9.copyWithin()方法浅将数组的一部分复制到同一数组中的另一个位置，并返回它而不修改其长度。 12var arr9 = [1, 2, 3, 4, 5, 6]console.log(arr9.copyWithin(1), arr9)","categories":[],"tags":[]},{"title":"node.js","slug":"js","date":"2019-07-24T09:34:09.000Z","updated":"2019-08-24T09:43:56.931Z","comments":true,"path":"2019/07/24/js/","link":"","permalink":"https://jsakura.github.io/2019/07/24/js/","excerpt":"","text":"node.jsNode 的 解决web服务的高并发性能问题 ,v8引擎本身就是用来浏览器解析js 的,node的js运行在服务器上的开发平台，node不是独立语言 是使用js进行编程，运行在js引擎上的（v8）Php jsp .net 这些都是要运行在服务器程序上 apache nginx tomat iis等http 服务器 ，node 不用建设自己的服务器软件上 ，node 没有web容器Node 特点 如何解决服务器高性能问题1.单线程Java 等服务器端语言，会为每一个客户端创建一个行的线程,如果想要让web应用支持更多的用户，就需要增加更多的服务器数量 ，web应用的软件成本就会提高Node 不是为每一个客户创建一个新的线程，而是仅仅只是使用一个线程，用户连接以后就会触发内部事件 通过非阻塞i/o，事件驱动，让node程序在宏观上也是处于并行的，单线程的好处 不用在创建线程，销毁的时间开销。i/o读取数据库，一个用户造成单线程的崩溃会导致整体奔溃 2.非阻塞i/o传统单线程在执行访问数据库以后会把整个线程都停下来等在数据库的结果返回才会执行后面的代码，也就是i/o阻塞了线程的执行node使用非阻塞i/o，执行操作在访问数据库的时候就会执行以后的代码，直到数据库的结果进行返回，当某个i/o执行完成会通知i/o的操作回调执行，也就是线程中有事件循环，不断的监测事件有没有未处理事件阻塞模式下，一个线程只能执行一件事情，提高吞吐量的必须通过多线程，非阻塞的模式是在执行计算机的操作，这个线程的执行率一直是100% 3.事件驱动 Node 在客户端请求建立连接，提交数据的行为就会触发对应的事件，在一个时刻只能执行一个事件的回调函数，但是在执行这个事件的回调函数中可以去执行其他的事件，然后在返回执行原事件的回调函数，这种机制叫做’事件环‘机制node底层大多数是用来写事件队列和回调函数队列的构建中的，用事件驱动来完成服务器的任务调度，单线程可以减少内存开销node中的i/o都是异步的，回调套回调，擅长与任务调度，业务过多的使用cpu计算也会导致阻塞单线程node是一个js的运行环境，node可以直接运行js ,浏览器是html的展示环境","categories":[],"tags":[]}],"categories":[],"tags":[]}